# Лабораторная работа №1 ИСТбд-12 Ченакин Владислав

# Написать программу, которая читая символы из бесконечной последовательности
# (эмулируется конечным файлом, читающимся поблочно), распознает,
# преобразует и выводит на экран лексемы по определенному правилу.
# Лексемы разделены пробелами. Преобразование делать по возможности через словарь.
# Для упрощения под выводом числа прописью подразумевается последовательный вывод всех цифр числа.
# Регулярные выражения использовать нельзя.

# Вариант 16.
# Четные двоичные числа, не превышающие 819110, в которых встречается не более одной серии из трех подряд идущих нуля.
# Выводит на экран цифры числа, исключая нули. Отдельно выводится прописью номер позиции, с которой начинается эта серия.

# Создание тестового файла
with open("data.txt", "w") as files:
    files.write("1010101 1011 1011000110 1010000100 101100 1011010 10100001010 101010 10101010 1010101 101010 10101 10101010 101010101 1010 11010 10110011000 10101010001 101001010 11111111")


# Словарь для преобразования позиции серии "000" в пропись (если позиция от 1 до 9)
numbers = {
    1 : "один", 2 : "два", 3 : "три",
    4 : "четыре", 5 : "пять", 6 : "шесть",
    7 : "семь", 8 : "восемь", 9 : "девять"
}

# Функция для поблочного чтения файла и обработки чисел
def read_file(filename):
    with open(filename, "r") as file: # Открываем файл в режиме чтения
        block = file.read(12) # Считываем файл блоками по 12 символов
        remainder = "" # Переменная для хранения остатка блока
        number = "" # Переменная для хранения текущего числа
        flag = 1 # Обозначение начала нового числа (если чётная, то чтение числа в блоке окончено и остальное идет в остаток)

        while block: # Пока есть данные в файле
            for i in block: # Проходим по символам текущего блока
                if i == " ": # Если встречаем пробел
                    flag += 1 # Чтение основного числа в блоке окончено
                    if is_valid_number(number) == 1: # Проверяем число на соответствие условиям
                        print(single_000(number)) # Выводим обработанное число
                    number = "" # Очищаем переменные для следующего числа
                    remainder = ""
                else: # Если считан не пробел, продолжаем запись числа
                    number += i;
                if (flag % 2 == 0): # Если чтение основного числа в блоке окончено
                    remainder += i #

            block = file.read(12) # Читаем следующий блок

        if number and is_valid_number(number) == 1: #  Проверяем последнее считанное число
            print(single_000(number))

# Функция проверки числа на соответствие условиям
def is_valid_number(number):
    # Проверка: число должно содержать только '0' и '1'
    for y in number:
        if y not in "01":
            return 0
    # Проверка: число не должно превышать 8191 (в десятичной системе)
    if int(number, 2) > 8191:
        print(number)
        return 0
    # Проверка: число должно быть чётным (оканчиваться на '0')
    if number[-1] != '0':
        return 0
    # Проверка: в числе может быть не более одной серии из трёх подряд идущих нулей
    if number.count("000") > 1:
        return 0
    return 1

# Функция преобразования числа по заданным правилам
def single_000(number):
    if ("000" in number):
        result = "1" * (number.count("1")) + " " + numbers[number.find("000") + 1]
    else:
        result = "1" * (number.count("1"))
    return result

read_file("data.txt")